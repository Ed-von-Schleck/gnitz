# gnitz/storage/wal.py

import os
import errno
from rpython.rlib import rposix, rposix_stat
from rpython.rtyper.lltypesystem import rffi, lltype
from rpython.rlib.objectmodel import newlist_hint
from gnitz.core import errors
from gnitz.storage import wal_format, mmap_posix


class WALReader(object):
    """
    Reader for the Z-Set Write-Ahead Log.
    Capable of reading multi-record blocks generated by ArenaZSetBatch.
    """

    def __init__(self, filename, schema):
        self.filename = filename
        self.schema = schema
        self.fd = -1
        self.last_inode = rffi.cast(rffi.ULONGLONG, 0)
        self.closed = False
        self._open_file()

    def _open_file(self):
        new_fd = rposix.open(self.filename, os.O_RDONLY, 0)
        try:
            st = rposix_stat.fstat(new_fd)
            if self.fd != -1:
                rposix.close(self.fd)
            self.fd = new_fd
            self.last_inode = rffi.cast(rffi.ULONGLONG, st.st_ino)
        except Exception:
            if new_fd != -1:
                rposix.close(new_fd)
            raise

    def _has_rotated(self):
        try:
            st = rposix_stat.stat(self.filename)
            return rffi.cast(rffi.ULONGLONG, st.st_ino) != self.last_inode
        except OSError as e:
            if e.errno == errno.ENOENT:
                return False
            raise e

    def read_next_block(self):
        """
        Reads the next logical block from the WAL.
        Returns a WALBlock object containing RawWALRecords, or None at EOF.
        """
        if self.closed:
            return None

        # Read the fixed-size header
        h_str = rposix.read(self.fd, wal_format.WAL_BLOCK_HEADER_SIZE)
        if not h_str or len(h_str) < wal_format.WAL_BLOCK_HEADER_SIZE:
            if self._has_rotated():
                self._open_file()
                h_str = rposix.read(self.fd, wal_format.WAL_BLOCK_HEADER_SIZE)
                if not h_str or len(h_str) < wal_format.WAL_BLOCK_HEADER_SIZE:
                    return None
            else:
                return None

        total_size = 0
        with rffi.scoped_str2charp(h_str) as h_p:
            header = wal_format.WALBlockHeaderView(h_p)
            total_size = header.get_total_size()

        if total_size < wal_format.WAL_BLOCK_HEADER_SIZE:
            raise errors.CorruptShardError("Invalid WAL block size in header")

        # Allocate raw memory for the full block (header + body)
        f_ptr = lltype.malloc(rffi.CCHARP.TO, total_size, flavor="raw")
        success = False
        try:
            # 1. Restore header into full buffer
            for i in range(wal_format.WAL_BLOCK_HEADER_SIZE):
                f_ptr[i] = h_str[i]

            # 2. Read and restore body
            body_sz = total_size - wal_format.WAL_BLOCK_HEADER_SIZE
            if body_sz > 0:
                b_str = rposix.read(self.fd, body_sz)
                if not b_str or len(b_str) < body_sz:
                    return None
                for i in range(body_sz):
                    f_ptr[wal_format.WAL_BLOCK_HEADER_SIZE + i] = b_str[i]

            # 3. Decode records and verify checksums via wal_format kernel
            res = wal_format.decode_wal_block(f_ptr, total_size, self.schema)
            success = True
            return res
        finally:
            if not success:
                lltype.free(f_ptr, flavor="raw")

    def iterate_blocks(self):
        while True:
            block = self.read_next_block()
            if block is None:
                break
            yield block

    def close(self):
        if not self.closed:
            if self.fd != -1:
                rposix.close(self.fd)
                self.fd = -1
            self.closed = True


class WALWriter(object):
    """
    Append-only writer for the Z-Set WAL.
    Natively consumes ArenaZSetBatch for zero-copy durability.
    """

    _immutable_fields_ = ["filename", "schema"]

    def __init__(self, filename, schema):
        self.filename = filename
        self.schema = schema
        self.closed = False
        self.fd = -1
        # Open in append mode with exclusive lock
        fd = rposix.open(filename, os.O_WRONLY | os.O_CREAT | os.O_APPEND, 0o644)
        try:
            if not mmap_posix.try_lock_exclusive(fd):
                raise errors.StorageError("WAL file is locked by another process")
            self.fd = fd
        except Exception:
            if fd != -1:
                rposix.close(fd)
            raise

    def append_batch(self, lsn, table_id, batch):
        """
        Serializes a ZSetBatch into the WAL.
        Segments records into blocks of up to 32MB to prevent integer overflow
        and memory pressure, then issues a single fsync for the entire batch.
        """
        if self.closed:
            raise errors.StorageError("Attempted to write to a closed WAL")
        
        num_records = batch.length()
        if num_records == 0:
            return

        # 32MB chunking threshold to keep transient allocations stable
        MAX_BLOCK_PAYLOAD = 32 * 1024 * 1024

        chunk_start_idx = 0
        current_chunk_size = 0
        current_chunk_count = 0

        for i in range(num_records):
            acc = batch.get_accessor(i)
            # Calculate physical bytes required for record and string blobs
            f_sz, h_sz = wal_format.compute_record_size(self.schema, acc)
            rec_total = f_sz + h_sz

            # If current record exceeds chunk budget, flush chunk to disk
            if current_chunk_count > 0 and (current_chunk_size + rec_total > MAX_BLOCK_PAYLOAD):
                wal_format.write_wal_block(
                    self.fd, lsn, table_id, batch, chunk_start_idx, current_chunk_count, self.schema
                )
                chunk_start_idx = i
                current_chunk_size = 0
                current_chunk_count = 0

            current_chunk_size += rec_total
            current_chunk_count += 1

        # Flush final chunk
        if current_chunk_count > 0:
            wal_format.write_wal_block(
                self.fd, lsn, table_id, batch, chunk_start_idx, current_chunk_count, self.schema
            )

        # Batch-durability: Convert N fsyncs into 1
        mmap_posix.fsync_c(self.fd)

    def truncate_before_lsn(self, lsn):
        """
        Resets the WAL for the given table. 
        Currently implemented as full truncate.
        """
        if self.closed or self.fd == -1:
            return

        mmap_posix.fsync_c(self.fd)
        rposix.ftruncate(self.fd, 0)
        rposix.lseek(self.fd, 0, 0)

    def close(self):
        if not self.closed:
            if self.fd != -1:
                mmap_posix.fsync_c(self.fd)
                mmap_posix.unlock_file(self.fd)
                rposix.close(self.fd)
                self.fd = -1
            self.closed = True
