# gnitz/storage/wal.py

import os
import errno
from rpython.rlib import rposix, rposix_stat, jit
from rpython.rtyper.lltypesystem import rffi, lltype
from rpython.rlib.rarithmetic import r_uint64
from rpython.rlib.objectmodel import newlist_hint
from gnitz.core import errors, xxh
from gnitz.storage import wal_format, mmap_posix, buffer as buffer_ops, wal_layout


class WALReader(object):
    """
    Reader for the Z-Set Write-Ahead Log.
    Capable of reading multi-record blocks generated by WALWriter.
    """

    def __init__(self, filename, schema):
        self.filename = filename
        self.schema = schema
        self.fd = -1
        self.last_inode = rffi.cast(rffi.ULONGLONG, 0)
        self.closed = False
        self._open_file()

    def _open_file(self):
        new_fd = rposix.open(self.filename, os.O_RDONLY, 0)
        try:
            st = rposix_stat.fstat(new_fd)
            if self.fd != -1:
                rposix.close(self.fd)
            self.fd = new_fd
            self.last_inode = rffi.cast(rffi.ULONGLONG, st.st_ino)
        except Exception:
            if new_fd != -1:
                rposix.close(new_fd)
            raise

    def _has_rotated(self):
        try:
            st = rposix_stat.stat(self.filename)
            return rffi.cast(rffi.ULONGLONG, st.st_ino) != self.last_inode
        except OSError as e:
            if e.errno == errno.ENOENT:
                return False
            raise e

    def read_next_block(self):
        """
        Reads the next logical block from the WAL.
        Returns a WALBlock object containing RawWALRecords, or None at EOF.
        """
        if self.closed:
            return None

        # Read the fixed-size header
        h_str = rposix.read(self.fd, wal_layout.WAL_BLOCK_HEADER_SIZE)
        if not h_str or len(h_str) < wal_layout.WAL_BLOCK_HEADER_SIZE:
            if self._has_rotated():
                self._open_file()
                h_str = rposix.read(self.fd, wal_layout.WAL_BLOCK_HEADER_SIZE)
                if not h_str or len(h_str) < wal_layout.WAL_BLOCK_HEADER_SIZE:
                    return None
            else:
                return None

        total_size = 0
        with rffi.scoped_str2charp(h_str) as h_p:
            header = wal_layout.WALBlockHeaderView(h_p)
            total_size = header.get_total_size()

        if total_size < wal_layout.WAL_BLOCK_HEADER_SIZE:
            raise errors.CorruptShardError("Invalid WAL block size in header")

        # Allocate raw memory for the full block (header + body)
        f_ptr = lltype.malloc(rffi.CCHARP.TO, total_size, flavor="raw")
        success = False
        try:
            # 1. Restore header into full buffer
            for i in range(wal_layout.WAL_BLOCK_HEADER_SIZE):
                f_ptr[i] = h_str[i]

            # 2. Read and restore body
            body_sz = total_size - wal_layout.WAL_BLOCK_HEADER_SIZE
            if body_sz > 0:
                b_str = rposix.read(self.fd, body_sz)
                if not b_str or len(b_str) < body_sz:
                    return None
                for i in range(body_sz):
                    f_ptr[wal_layout.WAL_BLOCK_HEADER_SIZE + i] = b_str[i]

            # 3. Decode records and verify checksums via wal_format kernel
            res = wal_format.decode_wal_block(f_ptr, total_size, self.schema)
            success = True
            return res
        finally:
            if not success:
                lltype.free(f_ptr, flavor="raw")

    def iterate_blocks(self):
        while True:
            block = self.read_next_block()
            if block is None:
                break
            yield block

    def close(self):
        if not self.closed:
            if self.fd != -1:
                rposix.close(self.fd)
                self.fd = -1
            self.closed = True


class WALWriter(object):
    """
    Append-only writer for the Z-Set WAL.
    Natively consumes ArenaZSetBatch for zero-copy durability.
    Uses a persistent streaming buffer to eliminate per-batch allocations.
    """

    _immutable_fields_ = ["filename", "schema", "block_buf", "allocator"]

    def __init__(self, filename, schema):
        self.filename = filename
        self.schema = schema
        self.closed = False
        self.fd = -1
        
        # Initialize to None (RPython high-level nulls)
        self.block_buf = None
        self.allocator = None

        fd = rposix.open(filename, os.O_WRONLY | os.O_CREAT | os.O_APPEND, 0o644)
        try:
            if not mmap_posix.try_lock_exclusive(fd):
                raise errors.StorageError("WAL file is locked by another process")
            self.fd = fd
            
            # Persistent 32MB buffer (Zero-allocation hot path)
            self.block_buf = buffer_ops.Buffer(32 * 1024 * 1024)
            self.allocator = wal_format.WALBlobAllocator(self.block_buf)
        except Exception:
            if fd != -1:
                rposix.close(fd)
            if self.block_buf:
                self.block_buf.free()
            raise

    def _flush_block(self, lsn, table_id, entry_count):
        """Backfills the block header and flushes the streaming buffer to disk."""
        if entry_count == 0:
            return

        total_size = self.block_buf.offset
        header = wal_layout.WALBlockHeaderView(self.block_buf.base_ptr)
        header.set_lsn(r_uint64(lsn))
        header.set_table_id(table_id)
        header.set_entry_count(entry_count)
        header.set_total_size(total_size)
        header.set_format_version(wal_layout.WAL_FORMAT_VERSION_CURRENT)

        # Calculate body checksum (excludes the 32-byte header itself)
        body_ptr = rffi.ptradd(self.block_buf.base_ptr, wal_layout.WAL_BLOCK_HEADER_SIZE)
        body_size = total_size - wal_layout.WAL_BLOCK_HEADER_SIZE
        if body_size > 0:
            header.set_checksum(xxh.compute_checksum(body_ptr, body_size))

        mmap_posix.write_c(self.fd, self.block_buf.base_ptr, rffi.cast(rffi.SIZE_T, total_size))

    def append_batch(self, lsn, table_id, batch):
        """
        Serializes a ZSetBatch into the WAL in a single pass.
        Splits into chunks of ~32MB to keep IO chunks stable.
        """
        if self.closed:
            raise errors.StorageError("Attempted to write to a closed WAL")
        
        num_records = batch.length()
        if num_records == 0:
            return

        MAX_BLOCK_PAYLOAD = 32 * 1024 * 1024
        
        # Reset streaming buffer for the new batch
        self.block_buf.reset()
        self.block_buf.alloc(wal_layout.WAL_BLOCK_HEADER_SIZE)
        current_chunk_count = 0

        for i in range(num_records):
            acc = batch.get_accessor(i)
            
            # Pre-calculate size for chunking and pointer stability
            f_sz, h_sz = wal_format.compute_record_size(self.schema, acc)
            rec_total = f_sz + h_sz

            # If this record would overflow the 32MB block, flush the current chunk
            if current_chunk_count > 0 and (self.block_buf.offset + rec_total > MAX_BLOCK_PAYLOAD):
                self._flush_block(lsn, table_id, current_chunk_count)
                self.block_buf.reset()
                self.block_buf.alloc(wal_layout.WAL_BLOCK_HEADER_SIZE)
                current_chunk_count = 0

            # Ensure capacity before writing to guarantee base_ptr remains stable
            self.block_buf.ensure_capacity(rec_total)
            
            pk = batch.get_pk(i)
            weight = batch.get_weight(i)
            
            # Direct serialization into streaming buffer
            wal_format.append_record_to_buffer(
                self.block_buf, self.schema, acc, pk, weight, self.allocator
            )
            current_chunk_count += 1

        # Flush the final (or only) block
        if current_chunk_count > 0:
            self._flush_block(lsn, table_id, current_chunk_count)

        # Durability: Issuing a single fsync for the entire batch
        mmap_posix.fsync_c(self.fd)

    def truncate_before_lsn(self, lsn):
        if self.closed or self.fd == -1:
            return
        mmap_posix.fsync_c(self.fd)
        rposix.ftruncate(self.fd, 0)
        rposix.lseek(self.fd, 0, 0)

    def close(self):
        if not self.closed:
            if self.fd != -1:
                mmap_posix.fsync_c(self.fd)
                mmap_posix.unlock_file(self.fd)
                rposix.close(self.fd)
                self.fd = -1
            if self.block_buf:
                self.block_buf.free()
                self.block_buf = None
            self.closed = True
